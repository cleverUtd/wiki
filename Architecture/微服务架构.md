理念
==

将大型、复杂且历时长久的应用在架构上设计为内聚的服务，这些服务能够随着时间的流逝而演化

对比整体架构
==

整体架构优点：

        开发起来较为容易

        测试起来很容易，因为你只需要启动一个应用

        容易进行部署，因为你只需要部署一个应用到对应服务器上（例如Java应用，就只需将一个war包放在tomcat目录下）

缺点：

        对于复杂应用来讲，整体架构就会变得很笨重

        对于开发者来说，大型的整体架构应用会很难理解和维护

        当某个应用组件(模块)的变更，必须要构建和部署整个庞大的应用

        整体架构使得很难去试验和采用新技术。例如，如果不重写整个应用的话，很难去尝试使用新的框架或技术，而重写整个应用是有风险且不现实的。导致的结果就是，必须坚守项目初期所选择的技术。


将应用分解为服务
==

        x轴扩展 在负载均衡器后面运行多个完全相同的应用

        Z轴扩展 每个服务器只负责数据的一个子集。系统中会有些组件负责将每个请求路由到对应的服务器。一个常用的路由条件就是请求的属性，如要访问实体的主键，这也就是所谓的sharding。另外一个常见的路由条件是客户类型。例如，相对于免费客户，应用可能需要对收费客户提供更高的SLA，这样的话，就需要将收费客户的请求路由到具有更高处理能力的不同服务器上面

        Y轴扩展 功能分解，将庞大的整体应用拆分为一组服务。每个服务实现一组相关的功能，如订单管理、客户管理等



微服务架构
==

优点：

        对于开发人员来说，代码更易于理解，开发更为高效，启动更为快速

        每个服务可以独立于其他服务进行部署

        提升故障的隔离性

        因为服务比较小，使用更好的语言和技术重写它们变得更为可行。这也意味着，如果对一项新技术的尝试失败的话，你尽可以抛弃这个成果，而不会对整个项目带来风险。这与采用整体架构有很大的区别，在整体架构中，初始的技术选择严重限制你将来采用不同语言和框架的能力

缺点：

        必须要处理创建分布式系统所带来的额外的复杂性

        必须要实现进程间的通信机制



服务间通讯机制
==

        异步消息，基于AMQP的消息队列

        同步http


数据管理
==

场景：在线商店中的每个顾客都有一个信用额度。当顾客试图下订单时，系统必须检查所有订单的总额不超过他们的信用额度。顾客相关信息部署在customerService中，订单信息则部署在orderService服务里。


#### 有些请求需要多个服务的数据，如何处理？

处理读:

    方法一：服务间通过rpc调用来检索，orderService通过http请求customerService检索到信用额度。优点：实现简单；确保能获得最新值。缺点： 必须保证customerService处于正常运行状态；因为额外的RPC调用增加响应的时间

    方法二： orderService保存一个副本。 优点：降低响应时间；确定：当customerService的信用额度更新时，同时要更新orderService的副本

处理更新请求,如何处理多个服务共有数据的更新请求

    方法一：分布式事务，例如，当更新顾客的信用额度时，CustomerService可以使用分布式事务同时更新自身的信用额度以及由OrderService维护的对应的信用额度。使用分布式事务能够确保数据始终是一致的，不足之处在于使用它会降低系统的可用性，因为为了事务能够提交，必须要求所有的参与者均可用。另外，分布式事务确实有些不再受欢迎了，现代的软件栈通常都不会支持它，如REST、NoSQL数据库等等  
   

    方法二： 事件驱动的异步更新，服务发布事件声明有些数据发生了变化，其他的服务订阅这些事件并更新它们的数据。例如，当CustomerService更新顾客的信用额度时，它发布一个CustomerCreditLimitUpdatedEvent，这个事件中包含了顾客的id以及新的信用额度。OrderService订阅这些事件并更新其信用额度的副本。

    优点：生产者和消费者实现了解耦；缺点：它为了可用性牺牲了一致性，可能需要实现事务补偿来执行逻辑回滚

关于分布式事务可参考： [分布式系统的事务处理](http://coolshell.cn/articles/10910.html)