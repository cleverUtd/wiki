const系列
==

主要负责把简单的数值类型送到栈顶,比如对应int型才该方式只能把-1,0,1,2,3,4,5（分别采用iconst_m1,iconst_0, iconst_1, iconst_2, iconst_3, iconst_4, iconst_5）送到栈顶。对于int型的其他数值使用push系列命令（比如bipush）

|操作符|说明|
|--|--|
|iconst_m1 | 将int型(-1)推送至栈顶 |
|iconst_0  | 将int型(0)推送至栈顶  |
|iconst_1  | 将int型(1)推送至栈顶  |
|iconst_2  | 将int型(2)推送至栈顶  |
|iconst_3  | 将int型(3)推送至栈顶  |
|iconst_4  | 将int型(4)推送至栈顶  |
|iconst_5  | 将int型(5)推送至栈顶  |
|lconst_0  | 将long型(0)推送至栈顶  |
|lconst_1  | 将long型(1)推送至栈顶  |
|fconst_0  | 将float型(0)推送至栈顶  |
|fconst_1  | 将float型(1)推送至栈顶  |
|dconst_0  | 将double型(0)推送至栈顶  |
|dconst_1  | 将double型(1)推送至栈顶  |


push系列
==

该系列命令负责把一个整形数字（长度比较小）送到到栈顶。该系列命令有一个参数，用于指定要送到栈顶的数字。

注意该系列命令只能操作一定范围内的整形数值，超出该范围的使用将使用ldc命令系列。


|操作符|说明|
|--|--|
| bipush | 将单字节的常量值(-128~127)推送至栈顶 |
|sipush | 将一个短整型常量值(-32768~32767)推送至栈顶 |


ldc系列
==

该系列命令负责把数值常量或String常量值从常量池中推送至栈顶。该命令后面需要跟一个表示常量在常量池中位置(编号)的参数，

哪些常量是放在常量池呢？比如：final static int id=32768;final static float double=6.5。

对于const系列命令和push系列命令操作范围之外的数值类型常量，都放在常量池中.

P.S: 所有不是通过new创建的String都是放在常量池中的。

|操作符|说明|
|--|--|
|ldc|将int, float或String型常量值从常量池中推送至栈顶|
|ldc_w|将int, float或String型常量值从常量池中推送至栈顶（宽索引）|
|ldc2_w|将long或double型常量值从常量池中推送至栈顶（宽索引）|


load系列
==

#### load系列A

该系列命令负责把本地变量的送到栈顶。这里的本地变量不仅可以是数值类型，还可以是引用类型。

对于前四个本地变量可以采用iload_0,iload_1,iload_2,iload_3(它们分别表示第0,1,2,3个整形变量)这种不到参数的简化命令形式。

对于第4以上的本地变量将使用iload命令这种形式，在它后面给一参数，以表示是对第几个(从0开始)本类型的本地变量进行操作。

对本地变量所进行的编号，是对所有类型的本地变量进行的（并不按照类型分类）。

对于非静态函数，第一变量是this,即其对于的操作是aload_0.

还有函数传入参数也算本地变量，在进行编号时，它是先于函数体的本地变量的。



|操作符|说明|
|--|--|
|iload|将指定的int型本地变量推送至栈顶|
|lload|将指定的long型本地变量推送至栈顶|
|fload|将指定的float型本地变量推送至栈顶|
|dload|将指定的double型本地变量推送至栈顶|
|aload|将指定的引用类型本地变量推送至栈顶|
|iload_0|将第一个int型本地变量推送至栈顶|
|iload_1|将第二个int型本地变量推送至栈顶|
|iload_2|将第三个int型本地变量推送至栈顶|
|iload_3|将第四个int型本地变量推送至栈顶|
|lload_0|将第一个long型本地变量推送至栈顶|
|lload_1|将第二个long型本地变量推送至栈顶|
|lload_2|将第三个long型本地变量推送至栈顶|
|lload_3|将第四个long型本地变量推送至栈顶|
|fload_0|将第一个float型本地变量推送至栈顶|
|fload_1|将第二个float型本地变量推送至栈顶|
|fload_2|将第三个float型本地变量推送至栈顶|
|fload_3|将第四个float型本地变量推送至栈顶|
|dload_0|将第一个double型本地变量推送至栈顶|
|dload_1|将第二个double型本地变量推送至栈顶|
|dload_2|将第三个double型本地变量推送至栈顶|
|dload_3|将第四个double型本地变量推送至栈顶|
|aload_0|将第一个引用类型本地变量推送至栈顶|
|aload_1|将第二个引用类型本地变量推送至栈顶|
|aload_2|将第三个引用类型本地变量推送至栈顶|
|aload_3|将第四个引用类型本地变量推送至栈顶|


### load系列B

该系列命令负责把数组的某项送到栈顶。该命令根据栈里内容来确定对哪个数组的哪项进行操作。

比如，如果有成员变量：final String names[]={"robin","hb"};

那么这句话：

String str=names[0];对应的指令为:

    17: aload_0         //将this引用推送至栈顶，即压入栈。

    18: getfield #5;  //Field names:[Ljava/lang/String;//将栈顶的指定的对象的第5个实例域（Field）的值（这个值可能是引用，这里就是引用）压入栈顶

    21: iconst_0       //数组的索引值（下标）推至栈顶，即压入栈

    22: aaload        //根据栈里内容来把name数组的第一项的值推至栈顶

    23: astore 5    //把栈顶的值存到str变量里。因为str在我的程序中是其所在非静态函数的第5个变量(从0开始计数)



|操作符|说明|
|--|--|
|iaload|将int型数组指定索引的值推送至栈顶|
|laload|将long型数组指定索引的值推送至栈顶|
|faload|将float型数组指定索引的值推送至栈顶|
|daload|将double型数组指定索引的值推送至栈顶|
|aaload|将引用型数组指定索引的值推送至栈顶|
|baload|将boolean或byte型数组指定索引的值推送至栈顶|
|caload|将char型数组指定索引的值推送至栈顶|
|saload|将short型数组指定索引的值推送至栈顶|



store系列
==

###store系列A

该系列命令负责把栈顶的值存入本地变量。这里的本地变量不仅可以是数值类型，还可以是引用类型。

如果是把栈顶的值存入到前四个本地变量的话，采用的是istore_0,istore_1，istore_2，istore_3(它们分别表示第0,1,2,3个本地整形变量)这种不到参数的简化命令形式。如果是把栈顶的值存入到第四个以上本地变量的话，将使用istore命令这种形式，在它后面给一参数，以表示是把栈顶的值存入到第几个(从0开始)本地变量中。

对本地变量所进行的编号，是对所有类型的本地变量进行的（并不按照类型分类）。

对于非静态函数，第一变量是this,它是只读的.

还有函数传入参数也算本地变量，在进行编号时，它是先于函数体的本地变量的。

|操作符|说明|
|--|--|
|istore|将栈顶int型数值存入指定本地变量|
|lstore|将栈顶long型数值存入指定本地变量|
|fstore|将栈顶float型数值存入指定本地变量|
|dstore|将栈顶double型数值存入指定本地变量|
|astore|将栈顶引用型数值存入指定本地变量|
|istore_0|将栈顶int型数值存入第一个本地变量|
|istore_1|将栈顶int型数值存入第二个本地变量|
|istore_2|将栈顶int型数值存入第三个本地变量|
|istore_3|将栈顶int型数值存入第四个本地变量|
|lstore_0|将栈顶long型数值存入第一个本地变量|
|lstore_1|将栈顶long型数值存入第二个本地变量|
|lstore_2|将栈顶long型数值存入第三个本地变量|
|lstore_3|将栈顶long型数值存入第四个本地变量|
|fstore_0|将栈顶float型数值存入第一个本地变量|
|fstore_1|将栈顶float型数值存入第二个本地变量|
|fstore_2|将栈顶float型数值存入第三个本地变量|
|fstore_3|将栈顶float型数值存入第四个本地变量|
|dstore_0|将栈顶double型数值存入第一个本地变量|
|dstore_1|将栈顶double型数值存入第二个本地变量|
|dstore_2|将栈顶double型数值存入第三个本地变量|
|dstore_3|将栈顶double型数值存入第四个本地变量|
|astore_0|将栈顶引用型数值存入第一个本地变量|
|astore_1|将栈顶引用型数值存入第二个本地变量|
|astore_2|将栈顶引用型数值存入第三个本地变量|
|astore_3|将栈顶引用型数值存入第四个本地变量|



### store系列B

该系列命令负责把栈顶项的值存到数组里。该命令根据栈里内容来确定对哪个数组的哪项进行操作。

int moneys[]=new int[5];

moneys[1]=100;

其对应的指令为：

    49: iconst_5

    50: newarray int

    52: astore 11

    54: aload 11

    56: iconst_1

    57: bipush 100

    59: iastore

    60: lload 6       //因为str在我的程序中是其所非静态在函数的第6个变量(从0开始计数).



|操作符|说明|
|--|--|
|iastore|将栈顶int型数值存入指定数组的指定索引位置|
|lastore|将栈顶long型数值存入指定数组的指定索引位置|
|fastore|将栈顶float型数值存入指定数组的指定索引位置|
|dastore|将栈顶double型数值存入指定数组的指定索引位置|
|aastore|将栈顶引用型数值存入指定数组的指定索引位置|
|bastore|将栈顶boolean或byte型数值存入指定数组的指定索引位置|
|castore|将栈顶char型数值存入指定数组的指定索引位置|
|sastore|将栈顶short型数值存入指定数组的指定索引位置|



pop系列
==

|操作符|说明|
|--|--|
|pop|将栈顶数值弹出 (数值不能是long或double类型的)|
|pop2|将栈顶的一个（long或double类型的)或两个数值弹出（其它）|
|dup|复制栈顶数值(数值不能是long或double类型的)并将复制值压入栈顶|
|dup_x1|复制栈顶数值(数值不能是long或double类型的)并将两个复制值压入栈顶|
|dup_x2|复制栈顶数值(数值不能是long或double类型的)并将三个（或两个）复制值压入栈顶|
|dup2|复制栈顶一个（long或double类型的)或两个（其它）数值并将复制值压入栈顶|
|dup2_x1|复制栈顶数值(long或double类型的)并将两个复制值压入栈顶|
|dup2_x2|复制栈顶数值(long或double类型的)并将三个（或两个）复制值压入栈顶|


栈顶元素数学操作及移位操作系列
==

该系列命令用于对栈顶元素行数学操作，和对数值进行移位操作。移位操作的操作数和要移位的数都是从栈里取得。

|操作符|说明|
|--|--|
|swap|将栈最顶端的两个数值互换(数值不能是long或double类型的)|
|iadd|将栈顶两int型数值相加并将结果压入栈顶|
|ladd|将栈顶两long型数值相加并将结果压入栈顶|
|fadd|将栈顶两float型数值相加并将结果压入栈顶|
|dadd|将栈顶两double型数值相加并将结果压入栈顶|
|isub|将栈顶两int型数值相减并将结果压入栈顶|
|lsub|将栈顶两long型数值相减并将结果压入栈顶|
|fsub|将栈顶两float型数值相减并将结果压入栈顶|
|dsub|将栈顶两double型数值相减并将结果压入栈顶|
|imul|将栈顶两int型数值相乘并将结果压入栈顶|
|lmul|将栈顶两long型数值相乘并将结果压入栈顶|
|fmul|将栈顶两float型数值相乘并将结果压入栈顶|
|dmul|将栈顶两double型数值相乘并将结果压入栈顶|
|idiv|将栈顶两int型数值相除并将结果压入栈顶|
|ldiv|将栈顶两long型数值相除并将结果压入栈顶|
|fdiv|将栈顶两float型数值相除并将结果压入栈顶|
|ddiv|将栈顶两double型数值相除并将结果压入栈顶|
|irem|将栈顶两int型数值作取模运算并将结果压入栈顶|
|lrem|将栈顶两long型数值作取模运算并将结果压入栈顶|
|frem|将栈顶两float型数值作取模运算并将结果压入栈顶|
|drem|将栈顶两double型数值作取模运算并将结果压入栈顶|
|ineg|将栈顶int型数值取负并将结果压入栈顶|
|lneg|将栈顶long型数值取负并将结果压入栈顶|
|fneg|将栈顶float型数值取负并将结果压入栈顶|
|dneg|将栈顶double型数值取负并将结果压入栈顶|
|ishl|将int型数值左移位指定位数并将结果压入栈顶|
|lshl|将long型数值左移位指定位数并将结果压入栈顶|
|ishr|将int型数值右（符号）移位指定位数并将结果压入栈顶|
|lshr|将long型数值右（符号）移位指定位数并将结果压入栈顶|
|iushr|将int型数值右（无符号）移位指定位数并将结果压入栈顶|
|lushr|将long型数值右（无符号）移位指定位数并将结果压入栈顶|
|iand|将栈顶两int型数值作“按位与”并将结果压入栈顶|
|land|将栈顶两long型数值作“按位与”并将结果压入栈顶|
|ior|将栈顶两int型数值作“按位或”并将结果压入栈顶|
|lor|将栈顶两long型数值作“按位或”并将结果压入栈顶|
|ixor|将栈顶两int型数值作“按位异或”并将结果压入栈顶|
|lxor|将栈顶两long型数值作“按位异或”并将结果压入栈顶|

自增减指令
==

该指令用于对本地(局部)变量进行自增减操作。该指令第一参数为本地变量的编号，第二个参数为自增减的数量。

比如对于代码：
```
  int d=10;
  d++;
  d+=2;
  d--;
```



其指令为：

    2:  bipush 10

    4:  istore_2//在我的程序中是其所在非静态函数的第2个变量(从0开始计数).

    5:  iinc 2, 1//在我的程序中是其所在非静态函数的第2个变量(从0开始计数).

    8:  iinc 2, 2

    11: iinc 2, -1

对本地变量所进行的编号，是对所有类型的本地变量进行的（并不按照类型分类）。



对于非静态函数，第一变量是this,它是只读的.还有函数传入参数也算本地变量，在进行编号时，它是先于函数体的本地变量的。



|操作符|说明|
|--|--|
|iinc|将指定int型变量增加指定值（i++, i--, i+=2）|

类型转化
==

该系列指令负责对栈顶数值类型进行类型转化，并把结果压入栈顶。

|操作符|说明|
|--|--|
|i2l|将栈顶int型数值强制转换成long型数值并将结果压入栈顶|
|i2f|将栈顶int型数值强制转换成float型数值并将结果压入栈顶|
|i2d|将栈顶int型数值强制转换成double型数值并将结果压入栈顶|
|l2i|将栈顶long型数值强制转换成int型数值并将结果压入栈顶|
|l2f|将栈顶long型数值强制转换成float型数值并将结果压入栈顶|
|l2d|将栈顶long型数值强制转换成double型数值并将结果压入栈顶|
|f2i|将栈顶float型数值强制转换成int型数值并将结果压入栈顶|
|f2l|将栈顶float型数值强制转换成long型数值并将结果压入栈顶|
|f2d|将栈顶float型数值强制转换成double型数值并将结果压入栈顶|
|d2i|将栈顶double型数值强制转换成int型数值并将结果压入栈顶|
|d2l|将栈顶double型数值强制转换成long型数值并将结果压入栈顶|
|d2f|将栈顶double型数值强制转换成float型数值并将结果压入栈顶|
|i2b|将栈顶int型数值强制转换成byte型数值并将结果压入栈顶|
|i2c|将栈顶int型数值强制转换成char型数值并将结果压入栈顶|
|i2s|将栈顶int型数值强制转换成short型数值并将结果压入栈顶|

比较指令
==

该系列指令用于对栈顶非int型元素进行比较，并把结果压入栈顶。

|操作符|说明|
|--|--|
|lcmp|比较栈顶两long型数值大小，并将结果（1，0，-1）压入栈顶|
|fcmpl|比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶|
|fcmpg|比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶|
|dcmpl|比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶|
|dcmpg|比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶|



有条件跳转指令系列
==

该系列指令用于对栈顶int型元素进行比较，根据结果进行跳转。第一个参数为要跳转到的代码的地址（这里的地址是指其指令在函数内是第几个指令）。注意对于boolean型，其实是把它当做int型来处理的。另外对于引用比较使用的时，其实是对存储的对象的地址进行比较。

|操作符|说明|
|--|--|
|ifeq|当栈顶int型数值等于0时跳转|
|ifne|当栈顶int型数值不等于0时跳转|
|iflt|当栈顶int型数值小于0时跳转|
|ifge|当栈顶int型数值大于等于0时跳转|
|ifgt|当栈顶int型数值大于0时跳转|
|ifle|当栈顶int型数值小于等于0时跳转|
|if_icmpeq|比较栈顶两int型数值大小，当结果等于0时跳转|
|if_icmpne|比较栈顶两int型数值大小，当结果不等于0时跳转|
|if_icmplt|比较栈顶两int型数值大小，当结果小于0时跳转|
|if_icmpge|比较栈顶两int型数值大小，当结果大于等于0时跳转|
|if_icmpgt|比较栈顶两int型数值大小，当结果大于0时跳转|
|if_icmple|比较栈顶两int型数值大小，当结果小于等于0时跳转|
|if_acmpeq|比较栈顶两引用型数值，当结果相等时跳转|
|if_acmpne|比较栈顶两引用型数值，当结果不相等时跳转|



无条件跳转指令系列
==

该系列指令用于指令的跳转

|操作符|说明|
|--|--|
|goto|无条件跳转|
|jsr|跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶|
|ret|返回至本地变量指定的index的指令位置（一般与jsr, jsr_w联合使用）|
|tableswitch|用于switch条件跳转，case值连续（可变长度指令）|
|lookupswitch|用于switch条件跳转，case值不连续（可变长度指令）|


返回
==

该系列指令用于从函数中返回。如果有返回值的话，都把函数的返回值放在栈中，以便它的调用方法取得它。



|操作符|说明|
|--|--|
|ireturn|从当前方法返回int|
|lreturn|从当前方法返回long|
|freturn|从当前方法返回float|
|dreturn|从当前方法返回double|
|areturn|从当前方法返回对象引用|
|return|从当前方法返回void|


域操作指令系列
==

该系列指令用于对静态域和非静态域进行读写。该系列命令需要跟一个表明域编号的参数

|操作符|说明|
|--|--|
|getstatic| 获取指定类的静态域，并将其值压入栈顶|
|putstatic|用栈顶的值为指定的类的静态域赋值|
|getfield|获取指定类的实例域，并将其值压入栈顶|
|putfield|用栈顶的值为指定的类的实例域赋值|

方法操作命令系列
==

该系列指令用于对静态方法和非静方法进行调用。该系列命令需要跟一个表明方法编号的参数。

如果方法有传入参数的话，则需要先压栈到栈顶。另外，方法的返回参数是保存到栈顶的，因此我们可以通过栈道值取得方法的返回值。

|操作符|说明|
|--|--|
|invokevirtual|调用实例  方法|
|invokespecial|调用超类构造方法，实例初始化方法，私有方法|
|invokestatic|调用静态方法|
|invokeinterface|调用接口方法| 

